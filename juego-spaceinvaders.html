<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Invaders - Arcade Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root { --bg-color: #0a0a0f; --card-bg: #1a1a2e; --text-color: #e0e0e0; --primary-color: #00d4ff; --secondary-color: #ff006e; --accent-color: #fb5607; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background-color: var(--bg-color); color: var(--text-color); font-family: 'Roboto', sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; margin: 0; }
        h1, h2, h3 { font-family: 'Orbitron', sans-serif; font-weight: 700; }
        .game-container { text-align: center; display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 600px; }
        .game-container h1 { font-size: 2.5rem; margin-bottom: 1rem; color: var(--primary-color); text-shadow: 0 0 10px var(--primary-color); }
        #gameCanvas { border: 2px solid var(--primary-color); border-radius: 10px; box-shadow: 0 0 20px rgba(0, 212, 255, 0.5); background-color: #000; max-width: 100%; height: auto; }
        .game-controls { margin-top: 1.5rem; font-family: 'Orbitron', sans-serif; font-size: 1.2rem; }
        /* Controles Táctiles para Móvil */
        .touch-controls { display: none; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 100; }
        .d-pad { position: relative; width: 150px; height: 150px; }
        .d-pad button { position: absolute; width: 50px; height: 50px; background: rgba(0, 212, 255, 0.3); border: 2px solid var(--primary-color); border-radius: 10px; color: var(--primary-color); font-size: 24px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background 0.2s; }
        .d-pad button:active { background: rgba(0, 212, 255, 0.6); }
        .d-pad .up { top: 0; left: 50px; } .d-pad .down { bottom: 0; left: 50px; }
        .d-pad .left { top: 50px; left: 0; } .d-pad .right { top: 50px; right: 0; }
        .d-pad .fire { top: 50px; left: 50px; background: rgba(255, 0, 110, 0.3); border-color: var(--secondary-color); color: var(--secondary-color); width: 50px; height: 50px; border-radius: 50%; }
        .d-pad .fire:active { background: rgba(255, 0, 110, 0.6); }
        @media (max-width: 768px) { .touch-controls { display: block; } .game-controls { display: none; } }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Space Invaders</h1>
        <canvas id="gameCanvas" width="600" height="500"></canvas>
        <div class="game-controls"><p>Flechas para mover, Espacio para disparar</p></div>
    </div>

    <!-- Controles Táctiles para Móvil -->
    <div class="touch-controls">
        <div class="d-pad">
            <button class="up" data-direction="up">↑</button>
            <button class="down" data-direction="down">↓</button>
            <button class="left" data-direction="left">←</button>
            <button class="right" data-direction="right">→</button>
            <button class="fire" data-direction="fire">FUEGO</button>
        </div>
    </div>

<script>
// ===================================================================
// INICIO DEL CÓDIGO DEL JUEGO (ENVUELTO EN UN IIFE)
// ===================================================================
(function() {
    'use strict';

    // --- VARIABLES DEL JUEGO ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Constantes del juego
    const PLAYER_WIDTH = 40;
    const PLAYER_HEIGHT = 25;
    const INVADER_WIDTH = 25;
    const INVADER_HEIGHT = 20;
    const BULLET_WIDTH = 4;
    const BULLET_HEIGHT = 10;
    const BUNKER_WIDTH = 60;
    const BUNKER_HEIGHT = 40;

    // Estado del juego
    let gameState = 'start'; // 'start', 'playing', 'gameOver', 'levelComplete'
    let score = 0;
    let lives = 3;
    let level = 1;
    let invaderSpeed = 0.5;
    let invaderDropDistance = 20;
    let invaderDirection = 1;
    let invaderAnimationFrame = 0;
    let lastShotTime = 0;
    const SHOT_COOLDOWN = 300; // en milisegundos
    let levelTransitionTime = 0;
    let bossLevel = false;
    let boss = null;
    let powerUps = [];
    let rapidFire = false;
    let rapidFireEndTime = 0;
    let shield = false;
    let shieldEndTime = 0;
    
    // --- VARIABLES PARA ARMAGEDÓN (SECRETO) ---
    const ARMAGEDDON_COOLDOWN = 30000; // 30 segundos
    let lastArmageddonTime = 0;

    // --- VARIABLES PARA CONGELACIÓN DEL TIEMPO (SECRETO) ---
    const TIME_FREEZE_DURATION = 5000; // 5 segundos
    const TIME_FREEZE_COOLDOWN = 25000; // 25 segundos
    let isTimeFrozen = false;
    let timeFreezeEndTime = 0;
    let lastTimeFreezeTime = 0;

    // Configuración de niveles ampliada
    const levelConfigs = [
        // Nivel 1 - Básico
        { rows: 4, cols: 8, speed: 0.5, dropDistance: 20, shootChance: 0.001, pattern: 'standard', name: "Nivel 1: Invasión Inicial", bossLevel: false },
        // Nivel 2 - Más invasores
        { rows: 4, cols: 10, speed: 0.6, dropDistance: 20, shootChance: 0.0015, pattern: 'standard', name: "Nivel 2: Refuerzos Enemigos", bossLevel: false },
        // Nivel 3 - Más rápido
        { rows: 5, cols: 10, speed: 0.7, dropDistance: 20, shootChance: 0.0015, pattern: 'standard', name: "Nivel 3: Aceleración", bossLevel: false },
        // Nivel 4 - Formación densa
        { rows: 5, cols: 11, speed: 0.6, dropDistance: 15, shootChance: 0.002, pattern: 'tight', name: "Nivel 4: Formación Densa", bossLevel: false },
        // Nivel 5 - Movimiento en zigzag
        { rows: 5, cols: 11, speed: 0.7, dropDistance: 15, shootChance: 0.002, pattern: 'zigzag', name: "Nivel 5: Patrón Zigzag", bossLevel: false },
        // Nivel 6 - Primer jefe
        { rows: 3, cols: 8, speed: 0.5, dropDistance: 20, shootChance: 0.001, pattern: 'standard', name: "Nivel 6: Enfrentamiento con el Jefe", bossLevel: true, bossType: 'basic' },
        // Nivel 7 - Más rápido con patrón de ataque
        { rows: 5, cols: 11, speed: 0.8, dropDistance: 15, shootChance: 0.0025, pattern: 'dive', name: "Nivel 7: Ataque en Picada", bossLevel: false },
        // Nivel 8 - Formación muy densa
        { rows: 6, cols: 12, speed: 0.7, dropDistance: 10, shootChance: 0.0025, pattern: 'tight', name: "Nivel 8: Muro de Invasores", bossLevel: false },
        // Nivel 9 - Patrón aleatorio
        { rows: 5, cols: 11, speed: 0.9, dropDistance: 15, shootChance: 0.003, pattern: 'random', name: "Nivel 9: Movimiento Errático", bossLevel: false },
        // Nivel 10 - Segundo jefe
        { rows: 4, cols: 8, speed: 0.6, dropDistance: 20, shootChance: 0.002, pattern: 'standard', name: "Nivel 10: Confrontación Final", bossLevel: true, bossType: 'advanced' },
        // Nivel 11 - Patrón mixto
        { rows: 5, cols: 11, speed: 1.0, dropDistance: 15, shootChance: 0.003, pattern: 'mixed', name: "Nivel 11: Ataque Coordinado", bossLevel: false },
        // Nivel 12 - Más invasores y rápido
        { rows: 7, cols: 13, speed: 1.1, dropDistance: 10, shootChance: 0.0035, pattern: 'tight', name: "Nivel 12: Superpoblación", bossLevel: false },
        // Nivel 13 - Patrón aleatorio extremo
        { rows: 6, cols: 12, speed: 1.2, dropDistance: 15, shootChance: 0.004, pattern: 'random', name: "Nivel 13: Caos Total", bossLevel: false },
        // Nivel 14 - Tercer jefe
        { rows: 5, cols: 10, speed: 0.8, dropDistance: 20, shootChance: 0.003, pattern: 'standard', name: "Nivel 14: El Destructor", bossLevel: true, bossType: 'ultimate' },
        // Nivel 15 - Nivel final
        { rows: 8, cols: 14, speed: 1.3, dropDistance: 10, shootChance: 0.005, pattern: 'mixed', name: "Nivel 15: La Batalla Final", bossLevel: false },
        // Nivel 16+ - Niveles infinitos con dificultad creciente
        { rows: 8, cols: 14, speed: 1.3, dropDistance: 10, shootChance: 0.005, pattern: 'mixed', name: "Nivel Infinito: Sobrevivencia Extrema", bossLevel: false, infinite: true }
    ];

    // Entidades del juego
    const player = {
        x: canvas.width / 2 - PLAYER_WIDTH / 2,
        y: canvas.height - 60,
        width: PLAYER_WIDTH,
        height: PLAYER_HEIGHT,
        speed: 5,
        isHit: false,
        invulnerableTime: 0
    };

    let bullets = [];
    let alienBullets = [];
    let invaders = [];
    let bunkers = [];
    let particles = []; // Para efectos de explosión
    let stars = []; // Para el fondo de estrellas
    let currentLevelConfig = null;

    // --- FUNCIONES DE INICIALIZACIÓN ---
    function init() {
        createStars();
        setupControls();
        resetGame();
    }

    function startGame() {
        resetGame();
        gameState = 'playing';
        gameLoop();
    }

    function resetGame() {
        score = 0;
        lives = 3;
        level = 1;
        player.x = canvas.width / 2 - PLAYER_WIDTH / 2;
        player.isHit = false;
        player.invulnerableTime = 0;
        bullets = [];
        alienBullets = [];
        particles = [];
        powerUps = [];
        rapidFire = false;
        shield = false;
        boss = null;
        bossLevel = false;
        lastArmageddonTime = 0;
        isTimeFrozen = false;
        timeFreezeEndTime = 0;
        lastTimeFreezeTime = 0;
        loadLevel(level);
    }

    function loadLevel(levelNumber) {
        if (levelNumber <= levelConfigs.length) {
            currentLevelConfig = {...levelConfigs[levelNumber - 1]};
        } else {
            // Para niveles más allá de los predefinidos, usar el último con dificultad creciente
            currentLevelConfig = {...levelConfigs[levelConfigs.length - 1]};
            currentLevelConfig.speed += 0.1 * (levelNumber - levelConfigs.length);
            currentLevelConfig.shootChance += 0.0005 * (levelNumber - levelConfigs.length);
            currentLevelConfig.name = `Nivel ${levelNumber}: Sobrevivencia Extrema`;
        }
        
        invaderSpeed = currentLevelConfig.speed;
        invaderDropDistance = currentLevelConfig.dropDistance;
        bossLevel = currentLevelConfig.bossLevel || false;
        
        bullets = [];
        alienBullets = [];
        particles = [];
        
        if (bossLevel) {
            createBoss(currentLevelConfig.bossType);
            createBunkers();
        } else {
            createInvaders();
            createBunkers();
        }
    }

    function nextLevel() {
        level++;
        levelTransitionTime = Date.now();
        loadLevel(level);
        
        // Mostrar mensaje de nivel completado
        gameState = 'levelComplete';
        setTimeout(() => {
            gameState = 'playing';
        }, 2000);
    }
    
    function createStars() {
        for (let i = 0; i < 100; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2,
                brightness: Math.random()
            });
        }
    }

    function createInvaders() {
        invaders = [];
        const rows = currentLevelConfig.rows;
        const cols = currentLevelConfig.cols;
        
        for(let r = 0; r < rows; r++) {
            for(let c = 0; c < cols; c++) {
                invaders.push({
                    x: c * (INVADER_WIDTH + 10) + 35,
                    y: r * (INVADER_HEIGHT + 15) + 50,
                    width: INVADER_WIDTH,
                    height: INVADER_HEIGHT,
                    type: r < 1 ? 'squid' : (r < 3 ? 'crab' : 'octopus'),
                    alive: true,
                    originalX: c * (INVADER_WIDTH + 10) + 35,
                    originalY: r * (INVADER_HEIGHT + 15) + 50,
                    moveTimer: 0
                });
            }
        }
    }

    function createBoss(type) {
        const bossType = type || 'basic';
        let health, maxHealth, width, height;
        
        switch(bossType) {
            case 'basic':
                health = maxHealth = 10;
                width = 100;
                height = 60;
                break;
            case 'advanced':
                health = maxHealth = 20;
                width = 120;
                height = 70;
                break;
            case 'ultimate':
                health = maxHealth = 30;
                width = 140;
                height = 80;
                break;
            default:
                health = maxHealth = 10;
                width = 100;
                height = 60;
        }
        
        boss = {
            x: canvas.width / 2 - width / 2,
            y: 50,
            width: width,
            height: height,
            health: health,
            maxHealth: maxHealth,
            type: bossType,
            moveDirection: 1,
            shootTimer: 0,
            specialAttackTimer: 0,
            alive: true
        };
    }
    
    function createBunkers() {
        bunkers = [];
        const bunkerCount = 4;
        const spacing = canvas.width / (bunkerCount + 1);
        for (let i = 1; i <= bunkerCount; i++) {
            bunkers.push({
                x: spacing * i - BUNKER_WIDTH / 2,
                y: canvas.height - 150,
                width: BUNKER_WIDTH,
                height: BUNKER_HEIGHT,
                blocks: createBunkerBlocks()
            });
        }
    }

    function createBunkerBlocks() {
        return [
            [0,0,1,1,1,1,1,1,0,0],
            [0,1,1,1,1,1,1,1,1,0],
            [1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1],
            [1,1,1,0,0,0,0,1,1,1],
            [1,1,0,0,0,0,0,0,1,1]
        ];
    }

    function createPowerUp(x, y) {
        const types = ['rapidFire', 'shield', 'extraLife', 'multiShot'];
        const type = types[Math.floor(Math.random() * types.length)];
        
        powerUps.push({
            x: x,
            y: y,
            width: 20,
            height: 20,
            type: type,
            speed: 2
        });
    }

    // --- FUNCIÓN ARMAGEDÓN (SECRETA) ---
    function activateArmageddon() {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        let armageddonScore = 0;
        invaders.forEach(inv => {
            if (inv.alive) {
                inv.alive = false;
                armageddonScore += (inv.type === 'squid' ? 30 : (inv.type === 'crab' ? 20 : 10));
                createExplosion(inv.x + inv.width / 2, inv.y + inv.height / 2, '#fff');
            }
        });

        if (bossLevel && boss && boss.alive) {
            boss.alive = false;
            armageddonScore += 500;
            createExplosion(boss.x + boss.width / 2, boss.y + boss.height / 2, '#fff');
        }
        
        score += armageddonScore + 100;
    }

    // --- FUNCIÓN CONGELACIÓN DEL TIEMPO (SECRETA) ---
    function activateTimeFreeze() {
        isTimeFrozen = true;
        timeFreezeEndTime = Date.now() + TIME_FREEZE_DURATION;
        ctx.fillStyle = 'rgba(0, 150, 255, 0.3)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // --- BUCLE PRINCIPAL DEL JUEGO ---
    function gameLoop() {
        if (gameState !== 'playing') return;
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

    // --- LÓGICA DE ACTUALIZACIÓN ---
    function update() {
        invaderAnimationFrame = (invaderAnimationFrame + 1) % 60;
        
        // Comprobar si la congelación del tiempo debe terminar
        if (isTimeFrozen && Date.now() > timeFreezeEndTime) {
            isTimeFrozen = false;
        }
        
        stars.forEach(star => {
            star.brightness += (Math.random() - 0.5) * 0.1;
            star.brightness = Math.max(0.3, Math.min(1, star.brightness));
        });

        if (player.isHit && Date.now() - player.invulnerableTime > 2000) {
            player.isHit = false;
        }

        updatePowerUps();

        bullets = bullets.filter(b => b.y > 0 && !b.hit);
        bullets.forEach(b => b.y -= 10);

        // El movimiento de las balas alienígenas se detiene si el tiempo está congelado
        if (!isTimeFrozen) {
            alienBullets = alienBullets.filter(b => b.y < canvas.height);
            alienBullets.forEach(b => b.y += 5);
        }

        // El movimiento de los invasores y el jefe se detiene si el tiempo está congelado
        if (!isTimeFrozen) {
            if (bossLevel && boss && boss.alive) {
                updateBoss();
            }

            if (!bossLevel) {
                invaders.forEach(inv => {
                    if (inv.alive && Math.random() < currentLevelConfig.shootChance) {
                        alienBullets.push({ x: inv.x + inv.width / 2 - 2, y: inv.y + inv.height });
                    }
                });
            }

            if (!bossLevel) {
                moveInvaders();
            }
        }
        
        particles = particles.filter(p => p.life > 0);
        particles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
        });
        
        checkCollisions();

        if (bossLevel) {
            if (!boss.alive) {
                nextLevel();
            }
        } else {
            if (invaders.filter(inv => inv.alive).length === 0) {
                nextLevel();
            }
        }

        if (lives <= 0) {
            gameState = 'gameOver';
        }
    }

    function updatePowerUps() {
        powerUps = powerUps.filter(p => p.y < canvas.height);
        powerUps.forEach(p => p.y += p.speed);

        powerUps.forEach(p => {
            if (p.x < player.x + player.width && 
                p.x + p.width > player.x && 
                p.y < player.y + player.height && 
                p.y + p.height > player.y) {
                
                applyPowerUp(p.type);
                powerUps = powerUps.filter(powerUp => powerUp !== p);
                createExplosion(p.x + p.width/2, p.y + p.height/2, '#0ff');
            }
        });
    }

    function applyPowerUp(type) {
        switch(type) {
            case 'rapidFire':
                rapidFire = true;
                rapidFireEndTime = Date.now() + 10000;
                break;
            case 'shield':
                shield = true;
                shieldEndTime = Date.now() + 15000;
                break;
            case 'extraLife':
                lives++;
                break;
            case 'multiShot':
                bullets.push({ x: player.x + player.width / 2 - BULLET_WIDTH / 2 - 10, y: player.y, hit: false });
                bullets.push({ x: player.x + player.width / 2 - BULLET_WIDTH / 2, y: player.y, hit: false });
                bullets.push({ x: player.x + player.width / 2 - BULLET_WIDTH / 2 + 10, y: player.y, hit: false });
                break;
        }
    }

    function updateBoss() {
        if (!boss || !boss.alive) return;
        
        boss.x += boss.moveDirection * 2;
        
        if (boss.x <= 0 || boss.x + boss.width >= canvas.width) {
            boss.moveDirection *= -1;
            boss.y += 20;
        }
        
        boss.shootTimer++;
        if (boss.shootTimer > 60) {
            alienBullets.push({ x: boss.x + boss.width / 2 - 2, y: boss.y + boss.height });
            
            if (boss.type === 'advanced' || boss.type === 'ultimate') {
                alienBullets.push({ x: boss.x + boss.width / 4 - 2, y: boss.y + boss.height });
                alienBullets.push({ x: boss.x + 3 * boss.width / 4 - 2, y: boss.y + boss.height });
            }
            
            if (boss.type === 'ultimate') {
                alienBullets.push({ x: boss.x + boss.width / 6 - 2, y: boss.y + boss.height });
                alienBullets.push({ x: boss.x + 5 * boss.width / 6 - 2, y: boss.y + boss.height });
            }
            
            boss.shootTimer = 0;
        }
        
        if (boss.type === 'advanced' || boss.type === 'ultimate') {
            boss.specialAttackTimer++;
            if (boss.specialAttackTimer > 180) {
                const bulletCount = boss.type === 'ultimate' ? 8 : 5;
                for (let i = 0; i < bulletCount; i++) {
                    setTimeout(() => {
                        alienBullets.push({ x: boss.x + boss.width / 2 - 2 + (Math.random() - 0.5) * 40, y: boss.y + boss.height });
                    }, i * 100);
                }
                boss.specialAttackTimer = 0;
            }
        }
    }

    function moveInvaders() {
        const pattern = currentLevelConfig.pattern;
        
        switch(pattern) {
            case 'standard': moveInvadersStandard(); break;
            case 'zigzag': moveInvadersZigzag(); break;
            case 'dive': moveInvadersDive(); break;
            case 'tight': moveInvadersTight(); break;
            case 'random': moveInvadersRandom(); break;
            case 'mixed':
                if (Math.floor(invaderAnimationFrame / 180) % 3 === 0) moveInvadersStandard();
                else if (Math.floor(invaderAnimationFrame / 180) % 3 === 1) moveInvadersZigzag();
                else moveInvadersDive();
                break;
            default: moveInvadersStandard();
        }
    }

    function moveInvadersStandard() {
        let edge = false;
        invaders.forEach(inv => {
            if (inv.alive) {
                inv.x += invaderDirection * invaderSpeed;
                if (inv.x <= 0 || inv.x + inv.width >= canvas.width) edge = true;
            }
        });
        if (edge) {
            invaderDirection *= -1;
            invaders.forEach(inv => inv.y += invaderDropDistance);
        }
    }

    function moveInvadersZigzag() {
        let edge = false;
        invaders.forEach(inv => {
            if (inv.alive) {
                inv.moveTimer++;
                if (inv.moveTimer % 60 < 30) {
                    inv.x += invaderDirection * invaderSpeed;
                } else {
                    inv.x -= invaderDirection * invaderSpeed;
                }
                
                if (inv.moveTimer % 120 === 0) {
                    inv.y += invaderDropDistance / 2;
                }
                
                if (inv.x <= 0 || inv.x + inv.width >= canvas.width) edge = true;
            }
        });
        if (edge) {
            invaderDirection *= -1;
            invaders.forEach(inv => inv.y += invaderDropDistance / 2);
        }
    }

    function moveInvadersDive() {
        let edge = false;
        invaders.forEach(inv => {
            if (inv.alive) {
                inv.moveTimer++;
                
                inv.x += invaderDirection * invaderSpeed;
                
                if (inv.moveTimer % 180 === 0 && Math.random() < 0.2) {
                    inv.dive = true;
                    inv.diveSpeed = 2 + Math.random() * 2;
                }
                
                if (inv.dive) {
                    inv.y += inv.diveSpeed;
                    inv.x += invaderDirection * invaderSpeed * 0.5;
                    
                    if (inv.y > canvas.height / 2 || inv.y > player.y - 100) {
                        inv.dive = false;
                        inv.y = inv.originalY;
                        inv.x = inv.originalX;
                    }
                }
                
                if (inv.x <= 0 || inv.x + inv.width >= canvas.width) edge = true;
            }
        });
        if (edge) {
            invaderDirection *= -1;
            invaders.forEach(inv => {
                if (!inv.dive) inv.y += invaderDropDistance;
            });
        }
    }

    function moveInvadersTight() {
        let edge = false;
        invaders.forEach(inv => {
            if (inv.alive) {
                inv.x += invaderDirection * invaderSpeed * 0.8;
                if (inv.x <= 0 || inv.x + inv.width >= canvas.width) edge = true;
            }
        });
        if (edge) {
            invaderDirection *= -1;
            invaders.forEach(inv => inv.y += invaderDropDistance * 0.7);
        }
    }

    function moveInvadersRandom() {
        let edge = false;
        invaders.forEach(inv => {
            if (inv.alive) {
                inv.x += invaderDirection * invaderSpeed;
                
                if (Math.random() < 0.1) {
                    inv.x += (Math.random() - 0.5) * 10;
                }
                
                if (Math.random() < 0.02) {
                    inv.y += invaderDropDistance * 0.5;
                }
                
                if (inv.x <= 0 || inv.x + inv.width >= canvas.width) edge = true;
            }
        });
        if (edge) {
            invaderDirection *= -1;
            invaders.forEach(inv => inv.y += invaderDropDistance);
        }
    }

    function checkCollisions() {
        bullets.forEach(b => {
            if (bossLevel && boss && boss.alive) {
                if (b.x < boss.x + boss.width && b.x + BULLET_WIDTH > boss.x && 
                    b.y < boss.y + boss.height && b.y + BULLET_HEIGHT > boss.y) {
                    boss.health--;
                    b.hit = true;
                    score += 50;
                    createExplosion(b.x, b.y, '#f00');
                    
                    if (boss.health <= 0) {
                        boss.alive = false;
                        score += 500;
                        createExplosion(boss.x + boss.width / 2, boss.y + boss.height / 2, '#ff0');
                        
                        if (Math.random() < 0.7) {
                            createPowerUp(boss.x + boss.width / 2, boss.y + boss.height / 2);
                        }
                    }
                }
            } else {
                invaders.forEach(inv => {
                    if (inv.alive && b.x < inv.x + inv.width && b.x + BULLET_WIDTH > inv.x && b.y < inv.y + inv.height && b.y + BULLET_HEIGHT > inv.y) {
                        inv.alive = false;
                        b.hit = true;
                        score += (inv.type === 'squid' ? 30 : (inv.type === 'crab' ? 20 : 10));
                        createExplosion(inv.x + inv.width / 2, inv.y + inv.height / 2);
                        
                        if (Math.random() < 0.05) {
                            createPowerUp(inv.x + inv.width / 2, inv.y + inv.height / 2);
                        }
                    }
                });
            }
        });

        if (!player.isHit) {
            alienBullets.forEach(b => {
                if (b.x < player.x + player.width && b.x + BULLET_WIDTH > player.x && b.y < player.y + player.height && b.y + BULLET_HEIGHT > player.y) {
                    if (shield) {
                        shield = false;
                        alienBullets = alienBullets.filter(bullet => bullet !== b);
                        createExplosion(player.x + player.width / 2, player.y + player.height / 2, '#0ff');
                    } else {
                        lives--;
                        player.isHit = true;
                        player.invulnerableTime = Date.now();
                        alienBullets = alienBullets.filter(bullet => bullet !== b);
                        createExplosion(player.x + player.width / 2, player.y + player.height / 2);
                    }
                }
            });
        }

        if (bossLevel && boss && boss.alive) {
            if (boss.y + boss.height >= player.y) {
                gameState = 'gameOver';
            }
        } else {
            invaders.forEach(inv => {
                if (inv.alive && inv.y + inv.height >= player.y) {
                    gameState = 'gameOver';
                }
            });
        }

        bullets.forEach(b => {
            bunkers.forEach(bunker => {
                checkBunkerCollision(bunker, b);
            });
        });
        alienBullets.forEach(b => {
            bunkers.forEach(bunker => {
                checkBunkerCollision(bunker, b);
            });
        });
    }

    function checkBunkerCollision(bunker, bullet) {
        const blockWidth = bunker.width / bunker.blocks[0].length;
        const blockHeight = bunker.height / bunker.blocks.length;
        const bCol = Math.floor((bullet.x - bunker.x) / blockWidth);
        const bRow = Math.floor((bullet.y - bunker.y) / blockHeight);

        if (bRow >= 0 && bRow < bunker.blocks.length && bCol >= 0 && bCol < bunker.blocks[0].length) {
            if (bunker.blocks[bRow][bCol] === 1) {
                bunker.blocks[bRow][bCol] = 0;
                bullet.hit = true;
                for(let i = 0; i < 3; i++) {
                    particles.push({
                        x: bullet.x,
                        y: bullet.y,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        life: 15,
                        color: '#0f0'
                    });
                }
            }
        }
    }

    function createExplosion(x, y, color = null) {
        const explosionColor = color || `hsl(${Math.random() * 60 + 15}, 100%, 50%)`;
        for(let i = 0; i < 15; i++) {
            particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                life: 30,
                color: explosionColor
            });
        }
    }

    // --- LÓGICA DE DIBUJO ---
    function draw() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        drawStars();
        
        // Efecto visual cuando el tiempo está congelado
        if (isTimeFrozen) {
            ctx.fillStyle = 'rgba(100, 200, 255, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        drawBunkers();
        drawPlayer();
        
        if (bossLevel) {
            drawBoss();
        } else {
            drawInvaders();
        }
        
        drawBullets();
        drawParticles();
        drawPowerUps();
        drawUI();

        if (gameState === 'start') drawStartScreen();
        if (gameState === 'gameOver') drawGameOverScreen();
        if (gameState === 'levelComplete') drawLevelCompleteScreen();
    }
    
    function drawStars() {
        ctx.fillStyle = '#fff';
        stars.forEach(star => {
            ctx.globalAlpha = star.brightness;
            ctx.fillRect(star.x, star.y, star.size, star.size);
        });
        ctx.globalAlpha = 1;
    }

    function drawPlayer() {
        if (player.isHit && Math.floor(Date.now() / 100) % 2 === 0) {
            return;
        }
        
        if (shield) {
            ctx.strokeStyle = '#0ff';
            ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 100) * 0.2;
            ctx.beginPath();
            ctx.arc(player.x + player.width/2, player.y + player.height/2, player.width, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1;
        }
        
        ctx.fillStyle = '#0ff';
        ctx.fillRect(player.x + 10, player.y + 15, 20, 10);
        ctx.fillRect(player.x + 18, player.y + 5, 4, 15);
        ctx.beginPath();
        ctx.moveTo(player.x, player.y + 15);
        ctx.lineTo(player.x + 10, player.y + 15);
        ctx.lineTo(player.x + 10, player.y + 25);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(player.x + PLAYER_WIDTH, player.y + 15);
        ctx.lineTo(player.x + 30, player.y + 15);
        ctx.lineTo(player.x + 30, player.y + 25);
        ctx.closePath();
        ctx.fill();
    }

    function drawInvaders() {
        invaders.forEach(inv => {
            if (inv.alive) {
                const frame = Math.floor(invaderAnimationFrame / 30) % 2;
                ctx.fillStyle = isTimeFrozen ? '#88f' : '#fff';
                drawInvaderShape(inv, frame);
            }
        });
    }

    function drawBoss() {
        if (!boss || !boss.alive) return;
        
        ctx.fillStyle = isTimeFrozen ? '#88f' : (boss.type === 'ultimate' ? '#f0f' : (boss.type === 'advanced' ? '#f00' : '#ff0'));
        ctx.fillRect(boss.x, boss.y, boss.width, boss.height);
        
        ctx.fillStyle = '#000';
        ctx.fillRect(boss.x + 20, boss.y + 10, 10, 10);
        ctx.fillRect(boss.x + boss.width - 30, boss.y + 10, 10, 10);
        ctx.fillRect(boss.x + boss.width/2 - 10, boss.y + 30, 20, 10);
        
        const healthPercentage = boss.health / boss.maxHealth;
        ctx.fillStyle = '#0f0';
        ctx.fillRect(boss.x, boss.y - 15, boss.width * healthPercentage, 5);
        ctx.strokeStyle = '#fff';
        ctx.strokeRect(boss.x, boss.y - 15, boss.width, 5);
    }

    function drawInvaderShape(invader, frame) {
        const x = invader.x;
        const y = invader.y;
        ctx.save();
        ctx.translate(x + invader.width / 2, y + invader.height / 2);

        if (invader.type === 'squid') {
            ctx.fillRect(-10, -5, 20, 3);
            ctx.fillRect(-8, -2, 3, 5);
            ctx.fillRect(5, -2, 3, 5);
            ctx.fillRect(-5, 3, 10, 3);
            if (frame === 1) {
                ctx.fillRect(-10, -8, 3, 3);
                ctx.fillRect(7, -8, 3, 3);
            }
        } else if (invader.type === 'crab') {
            ctx.fillRect(-10, -5, 20, 3);
            ctx.fillRect(-10, 0, 20, 3);
            ctx.fillRect(-12, -5, 3, 8);
            ctx.fillRect(9, -5, 3, 8);
            if (frame === 1) {
                ctx.fillRect(-5, 3, 3, 3);
                ctx.fillRect(2, 3, 3, 3);
            }
        } else {
            ctx.fillRect(-10, -5, 20, 5);
            ctx.fillRect(-5, 0, 10, 5);
            if (frame === 1) {
                ctx.fillRect(-12, -5, 3, 3);
                ctx.fillRect(9, -5, 3, 3);
                ctx.fillRect(-12, 2, 3, 3);
                ctx.fillRect(9, 2, 3, 3);
            }
        }
        ctx.restore();
    }

    function drawBunkers() {
        ctx.fillStyle = '#0f0';
        bunkers.forEach(bunker => {
            const blockWidth = bunker.width / bunker.blocks[0].length;
            const blockHeight = bunker.height / bunker.blocks.length;
            bunker.blocks.forEach((row, r) => {
                row.forEach((block, c) => {
                    if (block === 1) {
                        ctx.fillRect(bunker.x + c * blockWidth, bunker.y + r * blockHeight, blockWidth, blockHeight);
                    }
                });
            });
        });
    }

    function drawBullets() {
        ctx.fillStyle = '#ff0';
        bullets.forEach(b => ctx.fillRect(b.x, b.y, BULLET_WIDTH, BULLET_HEIGHT));
        ctx.fillStyle = isTimeFrozen ? '#88f' : '#f00';
        alienBullets.forEach(b => ctx.fillRect(b.x, b.y, BULLET_WIDTH, BULLET_HEIGHT));
    }
    
    function drawParticles() {
        particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life / 30;
            ctx.fillRect(p.x, p.y, 3, 3);
        });
        ctx.globalAlpha = 1;
    }

    function drawPowerUps() {
        powerUps.forEach(p => {
            ctx.save();
            ctx.translate(p.x + p.width/2, p.y + p.height/2);
            ctx.rotate(Date.now() / 500);
            
            switch(p.type) {
                case 'rapidFire': ctx.fillStyle = '#f0f'; break;
                case 'shield': ctx.fillStyle = '#0ff'; break;
                case 'extraLife': ctx.fillStyle = '#0f0'; break;
                case 'multiShot': ctx.fillStyle = '#ff0'; break;
            }
            
            ctx.fillRect(-p.width/2, -p.height/2, p.width, p.height);
            ctx.restore();
        });
    }

    function drawUI() {
        ctx.fillStyle = '#fff';
        ctx.font = '20px Orbitron';
        ctx.textAlign = 'left';
        ctx.fillText(`PUNTUACIÓN: ${score}`, 10, 30);
        ctx.textAlign = 'right';
        ctx.fillText(`NIVEL: ${level}`, canvas.width - 10, 30);
        ctx.fillText(`VIDAS: ${lives}`, canvas.width - 10, 55);
        
        if (currentLevelConfig && Date.now() - levelTransitionTime < 3000) {
            ctx.fillStyle = '#0ff';
            ctx.font = '25px Orbitron';
            ctx.textAlign = 'center';
            ctx.globalAlpha = Math.max(0, 1 - (Date.now() - levelTransitionTime) / 3000);
            ctx.fillText(currentLevelConfig.name, canvas.width / 2, canvas.height / 2);
            ctx.globalAlpha = 1;
        }
        
        if (rapidFire) {
            const timeLeft = Math.ceil((rapidFireEndTime - Date.now()) / 1000);
            ctx.fillStyle = '#f0f';
            ctx.font = '16px Orbitron';
            ctx.textAlign = 'left';
            ctx.fillText(`DISPARO RÁPIDO: ${timeLeft}s`, 10, 55);
        }
        
        if (shield) {
            const timeLeft = Math.ceil((shieldEndTime - Date.now()) / 1000);
            ctx.fillStyle = '#0ff';
            ctx.font = '16px Orbitron';
            ctx.textAlign = 'left';
            ctx.fillText(`ESCUDO: ${timeLeft}s`, 10, 75);
        }
    }

    function drawStartScreen() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#0ff';
        ctx.font = '50px Orbitron';
        ctx.textAlign = 'center';
        ctx.fillText('SPACE INVADERS', canvas.width / 2, canvas.height / 2 - 70);
        ctx.font = '20px Orbitron';
        ctx.fillText('Presiona ENTER para Jugar', canvas.width / 2, canvas.height / 2 + 20);
        ctx.fillText('¡Derrota a los invasores y avanza por los niveles!', canvas.width / 2, canvas.height / 2 + 50);
    }

    function drawGameOverScreen() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#f00';
        ctx.font = '60px Orbitron';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 30);
        ctx.fillStyle = '#fff';
        ctx.font = '25px Orbitron';
        ctx.fillText(`Puntuación Final: ${score}`, canvas.width / 2, canvas.height / 2 + 20);
        ctx.fillText(`Niveles Completados: ${level - 1}`, canvas.width / 2, canvas.height / 2 + 50);
        ctx.font = '20px Orbitron';
        ctx.fillText('Presiona ENTER para Jugar de Nuevo', canvas.width / 2, canvas.height / 2 + 90);
    }

    function drawLevelCompleteScreen() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#0f0';
        ctx.font = '50px Orbitron';
        ctx.textAlign = 'center';
        ctx.fillText(`NIVEL ${level} COMPLETADO`, canvas.width / 2, canvas.height / 2 - 30);
        ctx.font = '25px Orbitron';
        ctx.fillText(`Puntuación: ${score}`, canvas.width / 2, canvas.height / 2 + 20);
        ctx.fillText('Prepárate para el siguiente nivel...', canvas.width / 2, canvas.height / 2 + 50);
    }

    // --- MANEJO DE EVENTOS ---
    const handleKeyDown = (e) => {
        if (e.key === 'Enter') {
            if (gameState === 'start' || gameState === 'gameOver') {
                startGame();
            }
            return;
        }

        if (gameState !== 'playing') return;

        // --- MANEJO DE LA TECLA O PARA ARMAGEDÓN (SECRETO) ---
        if ((e.key === 'o' || e.key === 'O')) {
            const now = Date.now();
            if (now - lastArmageddonTime > ARMAGEDDON_COOLDOWN) {
                activateArmageddon();
                lastArmageddonTime = now;
            }
        }

        // --- MANEJO DE LA TECLA Z PARA CONGELACIÓN DEL TIEMPO (SECRETO) ---
        if ((e.key === 'z' || e.key === 'Z')) {
            const now = Date.now();
            if (now - lastTimeFreezeTime > TIME_FREEZE_COOLDOWN) {
                activateTimeFreeze();
                lastTimeFreezeTime = now;
            }
        }

        if (e.key === 'ArrowLeft' && player.x > 0) player.x -= player.speed;
        if (e.key === 'ArrowRight' && player.x < canvas.width - player.width) player.x += player.speed;
        
        if (e.key === ' ') {
            e.preventDefault();
            const now = Date.now();
            const cooldown = rapidFire ? 100 : SHOT_COOLDOWN;
            
            if (now - lastShotTime > cooldown) {
                bullets.push({ x: player.x + player.width / 2 - BULLET_WIDTH / 2, y: player.y, hit: false });
                lastShotTime = now;
            }
        }
    };

    const handleInput = (action) => {
        if (gameState !== 'playing') return;
        if (action === 'left' && player.x > 0) player.x -= player.speed;
        else if (action === 'right' && player.x < canvas.width - player.width) player.x += player.speed;
        else if (action === 'fire') {
            const now = Date.now();
            const cooldown = rapidFire ? 100 : SHOT_COOLDOWN;
            
            if (now - lastShotTime > cooldown) {
                bullets.push({ x: player.x + player.width / 2 - BULLET_WIDTH / 2, y: player.y, hit: false });
                lastShotTime = now;
            }
        }
    };
    
    const setupControls = () => {
        document.addEventListener('keydown', handleKeyDown);
        document.querySelectorAll('.d-pad button').forEach(button => {
            button.addEventListener('click', () => handleInput(button.dataset.direction));
            button.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput(button.dataset.direction); });
        });
    };

    window.stopGame = function() {
        console.log("Deteniendo Space Invaders...");
        gameState = 'stopped';
        document.removeEventListener('keydown', handleKeyDown);
        document.querySelectorAll('.d-pad button').forEach(button => {
            button.removeEventListener('click', () => handleInput(button.dataset.direction));
            button.removeEventListener('touchstart', (e) => { e.preventDefault(); handleInput(button.dataset.direction); });
        });
    };

    init();
    draw();

})(); // FIN DEL IIFE
// ===================================================================

</script>
</body>
</html>
