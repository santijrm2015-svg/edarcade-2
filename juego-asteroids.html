<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asteroids - Un Solo Archivo</title>
    <style>
        /* Estilos CSS para que se vea bien */
        body {
            background-color: #000;
            color: #0f0; /* Verde clásico de arcade */
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            text-align: center;
            overflow: hidden; /* Evita barras de scroll */
        }

        h1 {
            margin-bottom: 10px;
            text-shadow: 0 0 10px #0f0;
        }

        canvas {
            border: 2px solid #0f0;
            background-color: #000;
            box-shadow: 0 0 20px #0f0;
        }

        #gameInfo {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 1.2em;
        }

        #gameOverScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border: 2px solid #0f0;
            text-align: center;
            display: none; /* Oculto por defecto */
        }

        #gameOverScreen h2 {
            font-size: 3em;
            margin-bottom: 20px;
            color: #f00;
            text-shadow: 0 0 10px #f00;
        }

        #restartBtn {
            padding: 15px 30px;
            font-size: 1.2em;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
            background-color: #111;
            color: #0f0;
            border: 2px solid #0f0;
            border-radius: 5px;
            transition: background-color 0.3s, color 0.3s;
        }

        #restartBtn:hover {
            background-color: #0f0;
            color: #000;
        }
    </style>
</head>
<body>

    <h1>ASTEROIDS</h1>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <div id="gameInfo">
        Puntuación: <span id="score">0</span> | Vidas: <span id="lives">3</span>
    </div>

    <div id="gameOverScreen">
        <h2>GAME OVER</h2>
        <p>Puntuación Final: <span id="finalScore">0</span></p>
        <button id="restartBtn">Reiniciar Juego</button>
    </div>

    <script>
        // --- JAVASCRIPT ---

        // 1. CONFIGURACIÓN INICIAL
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreEl = document.getElementById('finalScore');
        const restartBtn = document.getElementById('restartBtn');

        // 2. CONSTANTES DEL JUEGO
        const SHIP_SIZE = 15;
        const SHIP_THRUST = 0.5;
        const SHIP_TURN_SPEED = 0.08;
        const FRICTION = 0.99;
        const ASTEROID_JAG = 0.4; // Qué tan irregulares son los asteroides
        const ASTEROID_NUM = 3; // Número inicial de asteroides
        const ASTEROID_SIZE = 50; // Tamaño del asteroide grande
        const BULLET_SPEED = 10;
        const BULLET_MAX_LIFE = 40; // Frames que vive una bala

        // 3. VARIABLES DEL JUEGO
        let score = 0;
        let lives = 3;
        let level = 1;
        let ship, asteroids = [], bullets = [];
        let gameOver = false;
        let keys = {};

        // 4. CLASES PARA OBJETOS DEL JUEGO

        class Ship {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.angle = 90 / 180 * Math.PI; // Apuntando hacia arriba
                this.radius = SHIP_SIZE / 2;
                this.thrusting = false;
                this.invulnerable = false;
                this.invulnerableTime = 120; // 2 segundos a 60fps
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Efecto de parpadeo cuando es invulnerable
                if (this.invulnerable && Math.floor(this.invulnerableTime / 5) % 2 === 0) {
                    ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
                } else {
                    ctx.strokeStyle = '#0f0';
                    ctx.fillStyle = '#0f0';
                }
                
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(SHIP_SIZE, 0);
                ctx.lineTo(-SHIP_SIZE, -SHIP_SIZE / 2);
                ctx.lineTo(-SHIP_SIZE / 2, 0);
                ctx.lineTo(-SHIP_SIZE, SHIP_SIZE / 2);
                ctx.closePath();
                ctx.stroke();

                // Fuego de propulsión
                if (this.thrusting) {
                    ctx.strokeStyle = 'orange';
                    ctx.fillStyle = 'red';
                    ctx.beginPath();
                    ctx.moveTo(-SHIP_SIZE / 2, 0);
                    ctx.lineTo(-SHIP_SIZE * 1.5, 0);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(-SHIP_SIZE * 1.2, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            update() {
                // Aplica fricción
                this.vx *= FRICTION;
                this.vy *= FRICTION;

                // Actualiza posición
                this.x += this.vx;
                this.y += this.vy;

                // Maneja la invulnerabilidad
                if (this.invulnerable) {
                    this.invulnerableTime--;
                    if (this.invulnerableTime <= 0) {
                        this.invulnerable = false;
                    }
                }

                // Envuelve la nave en los bordes
                if (this.x < 0) this.x = canvas.width;
                if (this.x > canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height;
                if (this.y > canvas.height) this.y = 0;
            }

            rotate(direction) {
                this.angle += direction * SHIP_TURN_SPEED;
            }

            thrust() {
                this.thrusting = true;
                this.vx += Math.cos(this.angle) * SHIP_THRUST;
                this.vy += Math.sin(this.angle) * SHIP_THRUST;
            }
            
            stopThrust() {
                this.thrusting = false;
            }

            shoot() {
                bullets.push(new Bullet(this.x, this.y, this.angle));
            }
        }

        class Asteroid {
            constructor(x, y, size) {
                this.x = x;
                this.y = y;
                this.size = size; // 'large', 'medium', 'small'
                const radius_map = { 'large': ASTEROID_SIZE, 'medium': ASTEROID_SIZE / 2, 'small': ASTEROID_SIZE / 4 };
                this.radius = radius_map[size];
                this.vx = (Math.random() * 2 - 1) * (ASTEROID_SIZE / this.radius); // Los más rápidos son más pequeños
                this.vy = (Math.random() * 2 - 1) * (ASTEROID_SIZE / this.radius);
                this.vertices = this.createVertices();
            }

            createVertices() {
                const vertices = [];
                const numVertices = 8 + Math.floor(Math.random() * 5);
                for (let i = 0; i < numVertices; i++) {
                    const angle = (i / numVertices) * Math.PI * 2;
                    const variance = 0.8 + Math.random() * ASTEROID_JAG;
                    vertices.push({
                        x: Math.cos(angle) * this.radius * variance,
                        y: Math.sin(angle) * this.radius * variance
                    });
                }
                return vertices;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
                for (let i = 1; i < this.vertices.length; i++) {
                    ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.restore();
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                // Envuelve el asteroide en los bordes
                if (this.x < 0) this.x = canvas.width;
                if (this.x > canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height;
                if (this.y > canvas.height) this.y = 0;
            }

            breakApart() {
                const newAsteroids = [];
                if (this.size === 'large') {
                    newAsteroids.push(new Asteroid(this.x, this.y, 'medium'));
                    newAsteroids.push(new Asteroid(this.x, this.y, 'medium'));
                    score += 20;
                } else if (this.size === 'medium') {
                    newAsteroids.push(new Asteroid(this.x, this.y, 'small'));
                    newAsteroids.push(new Asteroid(this.x, this.y, 'small'));
                    score += 50;
                } else { // small
                    score += 100;
                }
                return newAsteroids;
            }
        }

        class Bullet {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * BULLET_SPEED;
                this.vy = Math.sin(angle) * BULLET_SPEED;
                this.life = BULLET_MAX_LIFE;
                this.radius = 2;
            }

            draw() {
                ctx.save();
                ctx.fillStyle = '#0f0';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#0f0';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;

                // Envuelve la bala en los bordes
                if (this.x < 0) this.x = canvas.width;
                if (this.x > canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height;
                if (this.y > canvas.height) this.y = 0;
            }

            isExpired() {
                return this.life <= 0;
            }
        }

        // 5. FUNCIONES PRINCIPALES DEL JUEGO

        function init() {
            score = 0;
            lives = 3;
            level = 1;
            gameOver = false;
            ship = new Ship(canvas.width / 2, canvas.height / 2);
            asteroids = createAsteroids(ASTEROID_NUM + level);
            bullets = [];
            gameOverScreen.style.display = 'none';
            updateUI();
            gameLoop();
        }

        function createAsteroids(count) {
            const newAsteroids = [];
            for (let i = 0; i < count; i++) {
                let x, y;
                do {
                    x = Math.random() * canvas.width;
                    y = Math.random() * canvas.height;
                } while (dist(x, y, ship.x, ship.y) < ASTEROID_SIZE * 2 + ship.radius); // Asegura que no aparezcan sobre la nave
                
                newAsteroids.push(new Asteroid(x, y, 'large'));
            }
            return newAsteroids;
        }

        function gameLoop() {
            if (gameOver) return;

            // Limpia el canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; // Efecto de estela
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // --- MANEJO DE ENTRADA ---
            if (keys['ArrowLeft']) ship.rotate(-1);
            if (keys['ArrowRight']) ship.rotate(1);
            if (keys['ArrowUp']) ship.thrust();
            else ship.stopThrust();
            
            // --- ACTUALIZACIONES ---
            ship.update();
            bullets.forEach(bullet => bullet.update());
            asteroids.forEach(asteroid => asteroid.update());

            // Filtra balas expiradas
            bullets = bullets.filter(bullet => !bullet.isExpired());

            // --- DETECCIÓN DE COLISIONES ---
            // Balas vs Asteroides
            for (let i = bullets.length - 1; i >= 0; i--) {
                for (let j = asteroids.length - 1; j >= 0; j--) {
                    if (dist(bullets[i].x, bullets[i].y, asteroids[j].x, asteroids[j].y) < bullets[i].radius + asteroids[j].radius) {
                        const newAsteroids = asteroids[j].breakApart();
                        asteroids.splice(j, 1);
                        asteroids.push(...newAsteroids);
                        bullets.splice(i, 1);
                        updateUI();
                        break; // Sal del bucle de asteroides para evitar errores de índice
                    }
                }
            }

            // Nave vs Asteroides
            if (!ship.invulnerable) {
                for (let asteroid of asteroids) {
                    if (dist(ship.x, ship.y, asteroid.x, asteroid.y) < ship.radius + asteroid.radius) {
                        lives--;
                        updateUI();
                        if (lives <= 0) {
                            endGame();
                        } else {
                            ship = new Ship(canvas.width / 2, canvas.height / 2);
                            ship.invulnerable = true;
                        }
                        break;
                    }
                }
            }
            
            // --- DIBUJADO ---
            ship.draw();
            bullets.forEach(bullet => bullet.draw());
            asteroids.forEach(asteroid => asteroid.draw());

            // --- COMPROBACIÓN DE NUEVO NIVEL ---
            if (asteroids.length === 0) {
                level++;
                ship = new Ship(canvas.width / 2, canvas.height / 2);
                ship.invulnerable = true;
                asteroids = createAsteroids(ASTEROID_NUM + level);
            }

            requestAnimationFrame(gameLoop);
        }

        function endGame() {
            gameOver = true;
            finalScoreEl.textContent = score;
            gameOverScreen.style.display = 'block';
        }

        function updateUI() {
            scoreEl.textContent = score;
            livesEl.textContent = lives;
        }

        // Función auxiliar para calcular distancia
        function dist(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        // 6. EVENT LISTENERS
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ') {
                e.preventDefault(); // Evita que la página se desplace
                if (!gameOver) ship.shoot();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        restartBtn.addEventListener('click', init);

        // --- INICIA EL JUEGO ---
        init();

    </script>
</body>
</html>
