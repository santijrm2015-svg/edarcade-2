<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Breaker - Ed Arcade</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root { --bg-color: #0a0a0f; --primary-color: #00d4ff; --secondary-color: #ff006e; --accent-color: #fb5607; }
        body { background-color: var(--bg-color); color: #e0e0e0; font-family: 'Roboto', sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; margin: 0; }
        .game-header { position: absolute; top: 20px; left: 20px; z-index: 100; }
        .game-header a { font-family: 'Orbitron', sans-serif; color: var(--primary-color); text-decoration: none; font-size: 1.2rem; display: flex; align-items: center; gap: 10px; }
        .game-container { text-align: center; display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 550px; }
        .game-container h1 { font-family: 'Orbitron', sans-serif; font-size: 2.5rem; margin-bottom: 1rem; color: var(--primary-color); text-shadow: 0 0 10px var(--primary-color); }
        #gameCanvas { border: 2px solid var(--primary-color); border-radius: 10px; box-shadow: 0 0 20px rgba(0, 212, 255, 0.5); background-color: #111; max-width: 100%; height: auto; touch-action: none; }
        .game-controls { margin-top: 1.5rem; }
        .game-controls p { font-family: 'Orbitron', sans-serif; font-size: 1.2rem; }
        @media (max-width: 768px) { .game-controls p { display: none; } }
    </style>
</head>
<body>
    <div class="game-header"><a href="index.html"><span>&larr;</span><span>Volver al Arcade</span></a></div>
    <div class="game-container"><h1>Neon Breaker</h1><canvas id="gameCanvas" width="480" height="320"></canvas><div class="game-controls"><p>Mueve el ratón para controlar la pala</p></div></div>
    <script>
        const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
        let ballX = canvas.width / 2; let ballY = canvas.height - 30; let ballDX = 2; let ballDY = -2; const ballRadius = 8;
        let paddleHeight = 10; let paddleWidth = 75; let paddleX = (canvas.width - paddleWidth) / 2;
        let rightPressed = false; let leftPressed = false;
        const brickRowCount = 5; const brickColumnCount = 8; const brickWidth = 50; const brickHeight = 20; const brickPadding = 5; const brickOffsetTop = 30; const brickOffsetLeft = 20;
        let bricks = []; for(let c=0; c<brickColumnCount; c++) { bricks[c] = []; for(let r=0; r<brickRowCount; r++) { bricks[c][r] = { x: 0, y: 0, status: 1 }; } }
        let score = 0; let lives = 3;
        
        function mouseMoveHandler(e) { const relativeX = e.clientX - canvas.offsetLeft; if(relativeX > 0 && relativeX < canvas.width) { paddleX = relativeX - paddleWidth / 2; } }
        function touchMoveHandler(e) { e.preventDefault(); const relativeX = e.touches[0].clientX - canvas.offsetLeft; if(relativeX > 0 && relativeX < canvas.width) { paddleX = relativeX - paddleWidth / 2; } }

        document.addEventListener("mousemove", mouseMoveHandler);
        canvas.addEventListener("touchmove", touchMoveHandler, { passive: false });

        function collisionDetection() { for(let c=0; c<brickColumnCount; c++) { for(let r=0; r<brickRowCount; r++) { const b = bricks[c][r]; if(b.status == 1) { if(ballX > b.x && ballX < b.x + brickWidth && ballY > b.y && ballY < b.y + brickHeight) { ballDY = -ballDY; b.status = 0; score++; if(score == brickRowCount * brickColumnCount) { alert("¡GANASTE!"); document.location.reload(); } } } } } }
        function drawBall() { ctx.beginPath(); ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2); ctx.fillStyle = "#00d4ff"; ctx.fill(); ctx.closePath(); }
        function drawPaddle() { ctx.beginPath(); ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight); ctx.fillStyle = "#ff006e"; ctx.fill(); ctx.closePath(); }
        function drawBricks() { for(let c=0; c<brickColumnCount; c++) { for(let r=0; r<brickRowCount; r++) { if(bricks[c][r].status == 1) { const brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft; const brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop; bricks[c][r].x = brickX; bricks[c][r].y = brickY; ctx.beginPath(); ctx.rect(brickX, brickY, brickWidth, brickHeight); ctx.fillStyle = `hsl(${(r * 60 + c * 20) % 360}, 100%, 50%)`; ctx.fill(); ctx.closePath(); } } } }
        function drawScore() { ctx.font = "16px Orbitron"; ctx.fillStyle = "#fff"; ctx.fillText("Puntos: " + score, 8, 20); }
        function drawLives() { ctx.font = "16px Orbitron"; ctx.fillStyle = "#fff"; ctx.fillText("Vidas: " + lives, canvas.width - 65, 20); }
        function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); drawBricks(); drawBall(); drawPaddle(); drawScore(); drawLives(); collisionDetection();
            if(ballX + ballDX > canvas.width - ballRadius || ballX + ballDX < ballRadius) { ballDX = -ballDX; } if(ballY + ballDY < ballRadius) { ballDY = -ballDY; } else if(ballY + ballDY > canvas.height - ballRadius) { if(ballX > paddleX && ballX < paddleX + paddleWidth) { ballDY = -ballDY; } else { lives--; if(!lives) { ctx.font = "40px Orbitron"; ctx.fillStyle = "#ff006e"; ctx.fillText("GAME OVER", canvas.width/2 - 100, canvas.height/2); document.location.reload(); } else { ballX = canvas.width / 2; ballY = canvas.height - 30; ballDX = 2; ballDY = -2; paddleX = (canvas.width - paddleWidth) / 2; } } }
            ballX += ballDX; ballY += ballDY; requestAnimationFrame(draw);
        }
        draw();
    </script>
</body>
</html>
